---
title: "International (English) Names Dataset Creation"
date: "`r format(Sys.time(), '%d %B, %Y')`"
format:
  html:
    toc: true
    toc-location: left
    toc-expand: true
    df-print: paged
---

```{r setup}
library(readr)
library(readxl)
library(tidyverse); theme_set(theme_bw())
library(broom)
library(flextable)

options(scipen = 999)
```

# Purpose

While there are many projects around collating and exploring baby name data, I have yet to find one that looks at frequency (popularity) over time and country for all the countries I'm interested in.

* [Multinational (but no time dimension)](https://opendata.stackexchange.com/questions/46/multinational-list-of-popular-first-names-and-surnames)
* [CRAN `babynames` package (only USA until 2017)](https://cran.r-project.org/web/packages/babynames/index.html)
* [Australian data `ozbabynames` package (last updated 5+ years ago)](https://github.com/robjhyndman/ozbabynames)
    * [Another attempt to analyze this dataset](https://www.monicaalexander.com/posts/2019-20-01-babynames/)
* [DAMEgender gender estimator (no years)](https://damegender.davidam.com/) ([suspicious views on gender](https://github.com/davidam/damegender/blob/dev/faq.org))
* [First and Last Names Database (no years or counts, just rank)](https://github.com/philipperemy/name-dataset)
* [Popular Names by Country Dataset (excellent but fewer than 3k forenames)](https://github.com/sigpwned/popular-names-by-country-dataset)

There are some good and fairly comprehensive ones out there, but many of them don't document their gathering and wrangling processes or are designed for different purposes. Here is mine.

When designing linguistic stimuli, sometimes we use gender stereotypes to probe comprehension processes. Sometimes we just need a bunch of names in order to vary the content of sentences without distracting from other aspects. Sometimes we need gender-ambiguous names. Sometimes we need gender-balanced names. Sometimes we need names that evoke certain beliefs or stereotypes to create stimuli that allow us to probe different syntactic, semantic, and social phenomena. Regardless, the social properties of names change over time as new stereotypes and distributions come to the forefront and are incorporated into individuals understanding of the world.

My project aims to:

1. Collect information about the names (primarily) English-speaking people (in primarily English-speaking countries) are exposed to
2. Identify how exposure in peer groups and in parent/grandparent/child peer groups influences perceptions and stereotypes about names
3. Identify how views of gender influence perceptions and stereotypes about names
4. Investigate how perceptions and stereotypes about names influence related grammatical processes (e.g. coreference)
5. Investigate how perceptions and stereotypes about names influence unrelated grammatical processes (e.g. filled gap effects)
6. Provide a dataset and tools for building informed linguistics example sentences and stimuli
    * gender-fair name selection informed by participant age range
    * finding and selecting racially/ethnically representative names
    * generating age-appropriate lists of gender-balanced (unisex) names
    * identifying names perceived to be (more) 'nonbinary' or 'binary'
    * identifying names perceived to be (more) 'young' or 'old' (relative to participants' age)
    * identifying names marked for other stereotypes (e.g. race, country of origin, socio-economic class)
    * gathering this information *by region* and *by age*, as these stereotypes can vary internationally and generationally


# Gathering raw data

## USA

* Hadley Wickham's `babynames` package only goes to 2017, but that is an alternative for smaller scope projects
* [Beyond the Top 1000 Names](https://www.ssa.gov/OACT/babynames/limits.html)
* Rank info compiled from: [Popular Baby Names (by Birth Year; Number)](https://www.ssa.gov/OACT/babynames/index.html)
    * Ranks are eventually recalculated using the same method as used by the SSA (`ties.method = "first"`).
* Proportion info compiled from: [SSN Holders](https://www.ssa.gov/OACT/babynames/numberUSbirths.html)
    * Proportions are estimates based on SSN registrations in a given year and number of babies registered under a given name

```{r usa_input}
read_delim(file = list.files(path = "data/USA",
                             pattern = "yob",
                             full.names = TRUE),
           col_names = FALSE,
           id = "file",
           show_col_types = FALSE) |> 
  mutate(year = substr(file,13,16) |> as.integer()) |> 
  rename(name = X1, asab = X2, number = X3) |> 
  select(-file) |> 
  # join with SSN applications by year
  left_join(read_csv("data/USA/USA_SSA_applications_1880-2022.csv",
                     show_col_types = FALSE) |>
              rename(year = `year of birth`),
            by = join_by("year")) |> 
  group_by(year,asab) |> 
  # calculate proportion based on ASAB SSN applications
  mutate(proportion = case_when(asab == "M" ~ number/Male,
                                asab == "F" ~ number/Female),
         rank = rank(-number, ties.method = "first") |> as.integer(),
         name = str_to_title(name)) |> 
  select(-c("Male","Female","Total")) |> 
  mutate(region = "USA") -> names_USA
```

## Canada

* [Baby Names Observatory](https://www150.statcan.gc.ca/n1/pub/71-607-x/71-607-x2023021-eng.htm)
* Downloaded from: [https://www150.statcan.gc.ca/t1/tbl1/en/tv.action?pid=1710014701](https://www150.statcan.gc.ca/t1/tbl1/en/tv.action?pid=1710014701) on 1 November 2023

```{r}
read_csv(file = "data/Canada/17100147-eng/17100147.csv",
         show_col_types = FALSE) |> 
  select("REF_DATE","GEO","Sex at birth","First name at birth","Indicator","VALUE") |> 
  pivot_wider(names_from = Indicator, values_from = VALUE) |> 
  rename(year = REF_DATE, region = GEO,
         asab = `Sex at birth`,
         name = `First name at birth`,
         number = Frequency,
         rank = Rank,
         proportion = `Proportion (%)`) |> # proportion by ASAB
  mutate(name = str_to_title(name),
         proportion = proportion/100,
         asab = case_when(asab == "Male" ~ "M",
                          asab == "Female" ~ "F",
                          .default = "X")) -> names_Canada
```

## United Kingdom

### England and Wales

* [Baby names for England and Wales](https://www.ons.gov.uk/peoplepopulationandcommunity/birthsdeathsandmarriages/livebirths/datasets/babynamesinenglandandwalesfrom1996)
* Only up to 2021
* Does not distinguish between England and Wales

```{r}
read_excel("data/EnglandWales/babynames1996to2021_EnglandWales.xlsx", 
           sheet = "1", # boy baby names
           na = "[x]", 
           skip = 7) |> 
  pivot_longer(cols = 2:53,
               names_to = "year_type",
               values_to = "value") |> 
  separate_wider_delim(cols = year_type, delim = " ", names = c("year", "type")) |> 
  pivot_wider(names_from = type, values_from = value) |> 
  mutate(asab = "M", region = "England and Wales") |> 
  # join with girl baby names
  rbind(read_excel("data/EnglandWales/babynames1996to2021_EnglandWales.xlsx", 
                   sheet = "2", # girl baby names
                   na = "[x]", 
                   skip = 7) |> 
          pivot_longer(cols = 2:53,
                       names_to = "year_type",
                       values_to = "value") |> 
          separate_wider_delim(cols = year_type, 
                               delim = " ", 
                               names = c("year", "type")) |> 
          pivot_wider(names_from = type, values_from = value) |> 
          mutate(asab = "F", region = "England and Wales")) |> 
  # tidy and remove empty rows
  rename(name = Name, rank = Rank, number = Count) |> 
  filter(!is.na(number)) |> 
  group_by(year,asab) |> 
  mutate(proportion = number/sum(number, na.rm = TRUE),
         name = str_to_title(name)) |> 
  ungroup() -> names_EW
```


### Scotland

* National Records of Scotland: Full list 1974-2022 [here](https://www.nrscotland.gov.uk/statistics-and-data/statistics/statistics-by-theme/vital-events/names/babies-first-names/babies-first-names-2022)

```{r}
read_csv("data/Scotland/babies-first-names-all-names-all-years.csv",
         show_col_types = FALSE) |> 
  select(-position) |> # rank is not calculated the same way as for USA, position is a char string
  rename(year = yr, asab = sex, name = FirstForename) |> 
  mutate(asab = case_when(asab == "B" ~ "M",
                          asab == "G" ~ "F",
                          .default = "X"),
         region = "Scotland",
         name = str_to_title(name)) |> 
  group_by(year,asab) |> 
  mutate(proportion = number/sum(number, na.rm = TRUE)) |> 
  ungroup() -> names_Scotland
```

### Northern Ireland

* NISRA Data for Baby Name Dashboard: [https://www.nisra.gov.uk/publications/data-baby-names-dashboard](https://www.nisra.gov.uk/publications/data-baby-names-dashboard)
* Too many duplicates (due to missing diacritics?) so summing duplicates to calculate numbers by approximate spelling (and re-ranking)

```{r}
read_excel("data/NorthernIreland/Data for Dashboard 2022.xlsx", 
           sheet = "Table 1 - Ranks and Geography", 
           skip = 3) |> 
  rename(year = "Year of Registration",
         asab = "Sex",
         name = "First name",
         number = "Number Given this Name") |> 
  mutate(region = "Northern Ireland",
         asab = case_when(asab == 1 ~ "M",
                          asab == 2 ~ "F",
                          .default = "X"),
         name = str_to_title(name)) |> 
  group_by(year, name, asab) |> 
  summarise(number = sum(number), .groups = "keep") |> 
  ungroup(name) |> 
  # join with birth data
  left_join(read_excel("data/NorthernIreland/Section 3 - Births_Tables_2022_Revised_Final.xlsx", 
                       sheet = "Table 3.1", skip = 4) |> 
              rename(year = "Year") |> 
              filter(!is.na(Females)) |> 
              mutate(year = as.numeric(year)),
            by = join_by("year")) |> 
  # tidy and organize
  mutate(rank = rank(-number, ties.method = "first"),
         proportion = case_when(asab == "M" ~ number/Males,
                                asab == "F" ~ number/Females),
         region = "Northern Ireland") |> 
  select(-c(`All Births`, Males, Females)) -> names_NI
```


## New Zealand

* Top 100 names since 1954: [https://smartstart.services.govt.nz/news/baby-names](https://smartstart.services.govt.nz/news/baby-names)
* Minimal hand-editing of columns for readability (did not use `tidyxl`)

```{r message=FALSE}
read_excel("data/NewZealand/Top-100-girls-and-boys-names-since-1954-EDITED.xlsx", 
           sheet = "Boys' Names", 
           skip = 6) |> 
  rename(rank = Rank) |> 
  pivot_longer(cols = 2:139, 
               names_to = "X", 
               values_to = "Y",
               names_prefix = "x",
               values_transform = as.character) |> 
  filter(!is.na(rank)) |> 
  separate_wider_delim(cols = X, 
                        delim = "...", 
                        names = c("year", "type")) |> 
  mutate(type = case_when(as.numeric(type) %% 2 == 0 ~ "name",
                          as.numeric(type) %% 2 == 1 ~ "number")) |> 
  pivot_wider(names_from = type,
              values_from = "Y") |> 
  mutate(asab = "M") |> 
  # join with girl names
  rbind(read_excel("data/NewZealand/Top-100-girls-and-boys-names-since-1954-EDITED.xlsx", 
                   sheet = "Girls' Names", 
                   skip = 6) |> 
          rename(rank = Rank) |> 
          pivot_longer(cols = 2:139, 
                       names_to = "X", 
                       values_to = "Y",
                       names_prefix = "x",
                       values_transform = as.character) |> 
          filter(!is.na(rank)) |> 
          separate_wider_delim(cols = X, 
                               delim = "...", 
                               names = c("year", "type")) |> 
          mutate(type = case_when(as.numeric(type) %% 2 == 0 ~ "name",
                                  as.numeric(type) %% 2 == 1 ~ "number")) |> 
          pivot_wider(names_from = type,
                      values_from = "Y") |> 
          mutate(asab = "F")) |> 
  mutate(year = year |> as.integer(),
         number = number |> as.numeric(),
         name = str_to_title(name)) |> 
  # join with birth data
  left_join(read_delim("data/NewZealand/live_births_1954-2022-EDITED.txt", 
                       delim = "\t", escape_double = FALSE, 
                       na = "..", trim_ws = TRUE,
                       show_col_types = FALSE), 
            by = join_by(year)) |> 
  group_by(year,asab) |> 
  mutate(proportion = case_when(is.na(male) | is.na(female) ~ number/sum(number, na.rm = TRUE),#number/total, #(total/2)
                                asab == "M" ~ number/male,
                                asab == "F" ~ number/female),
         region = "New Zealand") |> 
  ungroup() |> 
  #### SEEMS TO HAVE A DUPLICATE MICHAEL, I DONT KNOW HOW BEST TO HANDLE THIS ####
  filter(year != 1988, rank != 100, name != "Michael") |> # Remove duplicate Michael - no evidence this is diacritics
  select(-c(male, female, total)) -> names_NZ
```


## Ireland

* [https://data.cso.ie/](https://data.cso.ie/) > 
* search "name" > 
* select Girls/Boys Names in Ireland with 3 or More Occurrences
* select Statistic (all)
* select Year (all)
* Download to CSV

```{r}
read_csv("data/Ireland/VSA50.20231102T161146-boys.csv",
         show_col_types = FALSE) |> 
  mutate(asab = "M",
         `Statistic Label` = case_when(substr(`Statistic Label`, 50,50)=="R" ~ "rank",
                                       TRUE ~ "number")) |>
  pivot_wider(names_from = `Statistic Label`,
              values_from = VALUE) |> 
  rbind(read_csv("data/Ireland/VSA60.20231102T161100-girls.csv",
                 show_col_types = FALSE) |> 
          mutate(asab = "F",
                 `Statistic Label` = case_when(substr(`Statistic Label`, 51,51)=="R" ~ "rank",
                                               TRUE ~ "number")) |>
          pivot_wider(names_from = `Statistic Label`,
                      values_from = VALUE)) |> 
  select(-UNIT) |> 
  rename(name = Names, year = Year) |> 
  filter(!is.na(number)) |> 
  mutate(region = "Ireland",
         name = str_to_title(name)) |> 
  group_by(year,asab) |> 
  mutate(proportion = number/sum(number, na.rm = TRUE)) |> 
  ungroup() -> names_Ireland
```

## Australia

* Australian birth data is collected at the State/Territory regional level *only*
* There is a 
* [South Australia](https://data.sa.gov.au/data/dataset/popular-baby-names)
* [New South Wales](https://data.nsw.gov.au/data/dataset/popular-baby-names-from-1952)
* [Queensland](https://www.data.qld.gov.au/dataset/top-100-baby-names)
* [Victoria](https://discover.data.vic.gov.au/dataset/popular-baby-names-victoria-api)
* [Tasmania](https://data.gov.au/data/organization/department-of-justice-tasmania?q=names&sort=score+desc%2C+metadata_modified+desc)
* [Northern Territory](https://nt.gov.au/law/bdm/popular-baby-names)
* [Australian Capital Territory](https://www.act.gov.au/our-canberra/latest-news/2022/december/the-most-popular-baby-names-of-2022) ([404 Data currently not available](https://www.act.gov.au/archive/archived-shortlinks/topbabynames); as of 3 November 2023)
* [Western Australia](https://bdm.justice.wa.gov.au/_apps/BabyNames/Default.aspx) (or [here](https://www.wa.gov.au/organisation/department-of-justice/the-registry-of-births-deaths-and-marriages/popular-baby-names))
* [Data Explorer for Births](https://explore.data.abs.gov.au/vis?tm=births&pg=0&df[ds]=ABS_ABS_TOPICS&df[id]=BIRTHS_SUMMARY&df[ag]=ABS&df[vs]=1.0.0&hc[Measure]=Births&pd=1975%2C&dq=5%2B4%2B1..A&ly[cl]=TIME_PERIOD) (from 1975 to 2022)
* National birth data since 1934 (but not by ASAB)

```
# Thanks to Hadas Kotek for parsing the JSON (3 November 2022)
import pandas as pd
import json
with open('victoria_babies_json_query_return.txt') as f:
    json_data = json.load(f)

pd.DataFrame(json_data['popular_baby_names']).to_csv('popular_baby_names.csv', index=False)
```

### Australian Capital Territory

```{r australia_regions}
# ACT
# no data, too small (only releases brief statement)
```

### New South Wales

```{r}
# new south wales
names_nsw <- read_csv("data/Australia/NSW/popular_baby_names_1952_to_2022-v2.csv",
                      show_col_types = FALSE) |> 
  rename(rank = Rank,
         name = Name,
         number = Number,
         asab = Gender,
         year = Year) |> 
  mutate(region = "New South Wales",
         name = str_to_title(name),
         asab = case_when(asab == "Male" ~ "M",
                          asab == "Female" ~ "F",
                          .default = "X"))
```

### Northern Territory

```{r}
# northern territory (hand-compiled)
names_nt <- read_csv("data/Australia/NT/NT_babynames_1980_2002-2022.csv",
                     show_col_types = FALSE) |> 
  group_by(year, asab) |>  
  mutate(rank = rank(-number, ties.method = "first") |> as.integer(),
         region = "Northern Territory",
         name = str_to_title(name)) |> 
  ungroup()
```

### Queensland

```{r}
# queensland
# 2006-2022
read_csv(file = list.files(path = "data/Australia/Queensland",
                           pattern = ".csv",
                           full.names = TRUE),
         col_names = TRUE,
         id = "file",
         show_col_types = FALSE) |> 
  mutate(file = str_remove(file, "data/Australia/Queensland/"),
         file = str_remove(file, "bdm_top-100-baby-names-"),
         file = str_remove(file, ".csv"),
         row = row_number()) |> 
  rename(year = file,
         name_F = "Girl Names",
         number_F = "Count of Girl Names",
         name_M = "Boy Names",
         number_M = "Count of Boy Names") |> 
  pivot_longer(cols = c(2:5),
               names_to = "label",
               values_to = "values",
               values_transform = list(values = as.character)) |> 
  separate(label, into = c("label", "asab"), sep = "_") |> 
  pivot_wider(names_from = label, values_from = values) |> 
  select(-row) |> 
  group_by(year, asab) |> 
  mutate(year = str_sub(year, start = -4, end = -1),
         number = as.numeric(number),
         year = as.numeric(year),
         rank = rank(-number, ties.method = "first") |> as.integer(),
         region = "Queensland") |> 
  ungroup() |> 
  filter(!is.na(name)) |> 
  # join with data from 1960-2005
  rbind(queensland_1960_2005 <- read_csv(file = list.files(path = "data/Australia/Queensland/long_format",
                                                           pattern = ".csv",
                                                           full.names = TRUE),
                                         col_names = TRUE,
                                         id = "file",
                                         show_col_types = FALSE) |> 
          rename(name = "Name",
                 asab = "Sex",
                 year = "Year",
                 number = "Count") |> 
          group_by(year, asab) |> 
          mutate(name = str_to_title(name),
                 asab = case_when(asab == "Male" ~ "M",
                                  asab == "Female" ~ "F",
                                  .default = "X"),
                 rank = rank(-number) |> as.integer(),
                 region = "Queensland") |> 
          ungroup() |> select(-file)) |> 
  mutate(name = str_to_title(name)) -> names_queensland
```

### South Australia

Possible South Australia name data problem:

* female_cy1968_top.csv : `(NOT`
* male_cy1968_top.csv : `(NOT`
* male_cy1968_top.csv : `(NOT`
* male_cy1976_top.csv : `?LIAM`

These are likely errors in data entry but they do not seem to be recoverable as this is the data as provided. Since `?LIAM` only occurs once, I believe it is safe to keep it in as noise, but since `(NOT` occurs 8 times in one year across both ASAB categories, I believe it should be removed. A brief exploration suggests there is not another word or words in 1968 in South Australia that have been erroneously included (i.e. whatever text followed 'NOT'), but I am not 100% certain.

```{r}
# south australia
read_csv(file = list.files(path = "data/Australia/SouthAustralia/Baby Names 1944-2013",
                           pattern = ".csv",
                           full.names = TRUE),
         col_names = TRUE,
         id = "file",
         show_col_types = FALSE) |> 
  mutate(file = str_remove(file, "data/Australia/SouthAustralia/Baby Names 1944-2013/"),
         file = str_remove(file, "_top.csv")) |> 
  rbind(# had to manually rename "Number" to "Amount" for 2016 files
    read_csv(file = list.files(path = "data/Australia/SouthAustralia",
                               pattern = ".csv",
                               full.names = TRUE),
             col_names = TRUE,
             id = "file",
             show_col_types = FALSE) |> 
      mutate(file = str_remove(file, "data/Australia/SouthAustralia/"),
             file = str_remove(file, ".csv"),
             file = str_remove(file, "top"))) |> 
  rename(name = "Given Name",
         number = "Amount") |> 
  # several files were only top 100 names, not all names, so this throws a warning about file name
  separate(file, into = c("asab","year"), sep = "_") |> 
  group_by(year, asab) |> 
  mutate(name = str_to_title(name),
         rank = rank(-number, ties.method = "first") |> as.integer(),
         asab = case_when(asab == "female" ~ "F",
                          asab == "male" ~ "M",
                          .default = "X"),
         region = "South Australia",
         year = str_sub(year, -4, -1) |> as.numeric()) |> 
  select(-Position) |> 
  filter(name != "TOTAL", # 2016 included "TOTAL" as if it were a name
         name != "Total", # 2016 included "TOTAL" as if it were a name
         name != "(Not") |> # REMOVE HIGHER FREQUENCY BAD DATA
  ungroup() -> names_soz
```

### Tasmania

```{r}
# tasmania (2015 and 2016 only, from website)
# taz_top_baby_names_for_2016 
read_excel("data/Australia/Tasmania/top-baby-names-for-2016.xlsx", # needs BIG cleaning
           col_names = FALSE, range = "A3:B136",
           .name_repair = "unique_quiet") |> 
  mutate(asab = "F",
         rank = rank(-`...2`, ties.method = "first")) |> 
  rbind(read_excel("data/Australia/Tasmania/top-baby-names-for-2016.xlsx", # needs BIG cleaning
                   col_names = FALSE, range = "A141:B284",
                   .name_repair = "unique_quiet") |> 
          mutate(asab = "M",
                 rank = rank(-`...2`, ties.method = "first"))) |> 
  rename(name = `...1`,
         number = `...2`) |> 
  mutate(name = str_to_title(name),
         year = 2016,
         region = "Tasmania") |> 
  # join taz_dataset_topbabynamesfor2015 girls names
  rbind(read_excel("data/Australia/Tasmania/dataset-topbabynamesfor2015.xlsx", 
                   sheet = "Top Baby Names 2015 - Female", 
                   col_names = FALSE, skip = 1,
                   .name_repair = "unique_quiet") |> 
          rename(name = `...1`,
                 number = `...2`) |> 
          mutate(name = str_to_title(name),
                 year = 2015,
                 rank = rank(-number) |> as.integer(),
                 asab = "F",
                 region = "Tasmania")) |> 
  # join taz_dataset_topbabynamesfor2015 boys names
  rbind(read_excel("data/Australia/Tasmania/dataset-topbabynamesfor2015.xlsx", 
                   sheet = "Top Baby Names 2015 - Male", 
                   col_names = FALSE, skip = 1,
                   .name_repair = "unique_quiet") |> 
          rename(name = `...1`,
                 number = `...2`) |> 
          mutate(name = str_to_title(name),
                 year = 2015,
                 rank = rank(-number) |> as.integer(),
                 asab = "M",
                 region = "Tasmania")) |> 
  mutate(name = str_to_title(name)) -> names_tasmania
```

### Victoria

```{r} 
# victoria (parsed from JSON)
read_csv("data/Australia/Victoria/popular_baby_names.csv",
         show_col_types = FALSE) |> 
  rename(rank = position,
         number = count,
         asab = sex) |> 
  mutate(region = "Victoria",
         asab = case_when(asab == "MALE" ~ "M",
                          asab == "FEMALE" ~ "F",
                          .default = "X"),
         name = str_to_title(name)) -> names_victoria
```

### Western Australia

```{r}
# western australia (hand-compiled from website)
#WA_babynames_1930_2022 <- 
read_csv("data/Australia/WesternAustralia/WA_babynames_1930-2022.csv",
         show_col_types = FALSE) |> 
  mutate(region = "Western Australia",
         name = str_to_title(name)) -> names_woz
```

### Australia Combined

```{r australia_together}
# combine australian data
names_nsw |> 
  rbind(names_nt) |> 
  rbind(names_queensland) |> 
  rbind(names_soz) |> 
  rbind(names_tasmania) |> 
  rbind(names_victoria) |> 
  rbind(names_woz) |> #-> names_Australia
  group_by(name, asab, year) |> 
  summarise(number = sum(number),
            .groups = "drop") |> 
  # join with detailed births information
  left_join(read_csv("data/Australia/ABS_BIRTHS_SUMMARY_1.0.0_4+5+1..A.csv",
                     show_col_types = FALSE) |> # messy data, needs cleaning
              rename(measure = `MEASURE: Measure`,
                     region2 = `REGION: Region`,
                     year = `TIME_PERIOD: Time Period`,
                     population = OBS_VALUE) |> 
              select(measure, region2, year, population) |> 
              filter(region2 == "AUS: Australia",
                     measure != "1: Births") |> 
              pivot_wider(names_from = measure,
                          values_from = population),
            by = join_by("year")) |> 
  mutate(proportion = case_when(asab == "M" ~ number/`4: Male births`,
                                asab == "F" ~ number/`5: Female births`),
         region = "Australia") |> 
  group_by(year, asab) |> 
  mutate(rank = rank(-number, ties.method = "first")) |> 
  select(year, name, number, rank, asab, region, proportion) |> 
  ungroup() |> 
  # join with older historical data (missing ASAB; solution *estimate* by multiplying annual births by .5)
  left_join(read_csv("data/Australia/Births registered â€“ 1934 to 2022(a).csv", skip = 1,
                     show_col_types = FALSE) |> 
              rename(year = Year, 
                     population = `Births registered`),
            by = join_by("year")) |> 
  mutate(proportion = case_when(is.na(proportion) ~ number/(population*.5), # no births by ASAB data, going by .5 of annual births
                                .default = proportion)) |> 
  select(-population) -> names_Australia
```

## South Africa

* Can't find annual name data beyond [this](https://www.statssa.gov.za/?p=11472)

## Other places

* Eventually, I would like to add India, China, Japan, Germany, Mexico, and perhaps other places that have large English-speaking populations or large immigrant communities in English-speaking countries. However, this requires resources beyond what I currently have.

# International Combined

```{r}
names_Australia |> 
  rbind(names_Canada) |> 
  rbind(names_EW) |> 
  rbind(names_Ireland) |> 
  rbind(names_NI) |> 
  rbind(names_NZ) |> 
  rbind(names_Scotland) |> 
  rbind(names_USA) -> names_combined
```

Write to file for ease of use elsewhere
```{r write_names_combined, eval=FALSE}
#write_csv(names_combined, "data/large_files/names_combined.csv")

#write_csv(names_Australia, "data/large_files/names_Australia.csv")
#write_csv(names_Canada, "data/large_files/names_Canada.csv")
#write_csv(names_EW, "data/large_files/names_EW.csv")
#write_csv(names_Ireland, "data/large_files/names_Ireland.csv")
#write_csv(names_NI, "data/large_files/names_NI.csv")
#write_csv(names_NZ, "data/large_files/names_NZ.csv")
#write_csv(names_Scotland, "data/large_files/names_Scotland.csv")
#write_csv(names_USA, "data/large_files/names_USA.csv")
```

# Experiments and norming

Getting different types of log ratios for each name in different breakdowns.

```{r}
names_combined |> 
    # not useful right now
  select(-c(rank, proportion)) |> 
    # remove default baby names
  filter(!name %in% c("Baby","Infant","Female","Notnamed","Stillborn","Unborn","Unnamed","Unknown","Unkown")) |> 
  pivot_wider(names_from = asab,
              values_from = number,
              values_fill = 0) |> 
  rename(afab = `F`, amab = M) |> 
  mutate(annual.regional.log.ratio = case_when(afab > 0 & amab > 0 ~ abs(log(afab/amab)),
                                               .default = NA)) -> annual.regional.breakdown

names_combined |> 
    # not useful right now
  select(-c(rank, proportion)) |> 
    # remove default baby names
  filter(!name %in% c("Baby","Infant","Female","Notnamed","Stillborn","Unborn","Unnamed","Unknown","Unkown")) |> 
  pivot_wider(names_from = asab,
              values_from = number,
              values_fill = NA) |> 
  rename(afab = `F`, amab = M) |> 
  group_by(name,year) |> 
  summarise(annual.log.ratio = (sum(afab, na.rm = TRUE)/sum(amab, na.rm = TRUE)) |> log() |> abs(),
            regions = n_distinct(region),
            total_afab = sum(afab, na.rm = TRUE),
            total_amab = sum(amab, na.rm = TRUE),
            total_people = sum(afab, na.rm = TRUE)+sum(amab, na.rm = TRUE),
            .groups = "drop") |> #view() #
  mutate(annual.log.ratio = case_when(annual.log.ratio > 1000 ~ NA,
                                      .default = annual.log.ratio)) -> annual.breakdown

names_combined |> 
    # not useful right now
  select(-c(rank, proportion)) |> 
    # remove default baby names
  filter(!name %in% c("Baby","Infant","Female","Notnamed","Stillborn","Unborn","Unnamed","Unknown","Unkown")) |> 
  pivot_wider(names_from = asab,
              values_from = number,
              values_fill = NA) |> 
  rename(afab = `F`, amab = M) |> 
  group_by(name,region) |> 
  summarise(regional.log.ratio = (sum(afab, na.rm = TRUE)/sum(amab, na.rm = TRUE)) |> log() |> abs(),
            years = n_distinct(year),
            total_afab = sum(afab, na.rm = TRUE),
            total_amab = sum(amab, na.rm = TRUE),
            total_people = sum(afab, na.rm = TRUE)+sum(amab, na.rm = TRUE),
            .groups = "drop") |> #view() #
  mutate(regional.log.ratio = case_when(regional.log.ratio > 1000 ~ NA,
                                        .default = regional.log.ratio)) -> regional.breakdown

names_combined |> 
    # not useful right now
  select(-c(rank, proportion)) |> 
    # remove default baby names
  filter(!name %in% c("Baby","Infant","Female","Notnamed","Stillborn","Unborn","Unnamed","Unknown","Unkown")) |> 
  pivot_wider(names_from = asab,
              values_from = number,
              values_fill = NA) |> 
  rename(afab = `F`, amab = M) |> 
  group_by(name) |> 
  summarise(log.ratio = (sum(afab, na.rm = TRUE)/sum(amab, na.rm = TRUE)) |> log() |> abs(),
            regions = n_distinct(region),
            years = n_distinct(year),
            total_afab = sum(afab, na.rm = TRUE),
            total_amab = sum(amab, na.rm = TRUE),
            total_people = sum(afab, na.rm = TRUE)+sum(amab, na.rm = TRUE),
            .groups = "drop") |> #view() #
  mutate(log.ratio = case_when(log.ratio > 1000 ~ NA,
                               .default = log.ratio)) -> combined.breakdown
```


```{r test}
combined.breakdown |> 
  mutate(plotem = case_when(name %in% c("Sage","Sevyn","Tenzin","Lakota") ~ "plot",
                            .default = NA)) |> 
  filter(log.ratio < 2) |> 
  ggplot(aes(x = log.ratio, y = total_people)) +
  theme_bw() +
  geom_text(aes(label = name), size = 1.5, color = "black") +
  geom_label(aes(label = name, color = plotem, fill = plotem), size = 1.5) +
  #geom_point(alpha = .5) +
  #ggrepel::geom_text_repel(aes(label = name), max.overlaps = 40) +
  scale_y_log10() +
  #facet_wrap(~region, scales = "free_y") +
  scale_x_continuous(breaks = seq(from = 0, to = 16, by = 1)) +
  scale_color_manual(values = c(NULL,"red"), na.value = NA) +
  scale_fill_manual(values = c(NULL,"white"), na.value = NA) +
  NULL


regional.breakdown |> 
  filter(region == "USA",
         #regional.log.ratio > 5,
         #regional.log.ratio < 6
         ) |> 
  ggplot(aes(x = regional.log.ratio, y = total_people, color = region)) +
  theme_bw() +
  #geom_point(alpha = .5) +
  #ggrepel::geom_text_repel(aes(label = name), max.overlaps = 40) +
  geom_text(aes(label = name), size = 2) +
  #scale_y_log10() +
  #facet_wrap(~region, scales = "free_y") +
  scale_x_continuous(breaks = seq(from = 0, to = 16, by = 1)) +
  NULL

regional.breakdown |> 
  filter(region == "New Zealand",
         #regional.log.ratio > 5
  ) |> 
  ggplot(aes(x = regional.log.ratio, y = total_people, color = region)) +
  theme_bw() +
  geom_point(alpha = .5) +
  ggrepel::geom_text_repel(aes(label = name), max.overlaps = 40) +
  #scale_y_log10() +
  #facet_wrap(~region, scales = "free_y") +
  scale_x_continuous(breaks = seq(from = 0, to = 16, by = 1)) +
  NULL

regional.breakdown |> 
  filter(region == "Australia",
         #regional.log.ratio > 5
  ) |> 
  ggplot(aes(x = regional.log.ratio, y = total_people, color = region)) +
  theme_bw() +
  geom_point(alpha = .5) +
  #ggrepel::geom_text_repel(aes(label = name), max.overlaps = 40) +
  #scale_y_log10() +
  #facet_wrap(~region, scales = "free_y") +
  scale_x_continuous(breaks = seq(from = 0, to = 16, by = 1)) +
  NULL

regional.breakdown |> 
  filter(region == "Canada",
         #regional.log.ratio > 5
  ) |> 
  ggplot(aes(x = regional.log.ratio, y = total_people, color = region)) +
  theme_bw() +
  geom_point(alpha = .5) +
  #ggrepel::geom_text_repel(aes(label = name), max.overlaps = 40) +
  #scale_y_log10() +
  #facet_wrap(~region, scales = "free_y") +
  scale_x_continuous(breaks = seq(from = 0, to = 16, by = 1)) +
  NULL

```


## List of names for Name Explorer ratings

In order to elicit ratings of the names in this dataset for research and norming purposes, I need to create a list of all the names without any repeats. I will format it for use in Gorilla (online survey tool).

Here is a table of all the names and their frequencies in the database as rounded to the nearest 100 (number of years for region).

```{r}
names_combined |> 
  group_by(name) |> 
  summarise(count = n(),
            .groups = "drop") |> 
  #filter(count > 3) |> 
  mutate(#freq_block = round(count, digits = -1), # old spreadsheet
         freq_block = case_when(count <= 100 ~ round(count, digits = -1),
                                .default = round(count, digits = -2))
         )
```

A summary of how many names fall into each frequency block

```{r}
names_combined |> 
  group_by(name) |> 
  summarise(count = n(),
            .groups = "drop") |> 
  mutate(freq_block = case_when(count <= 100 ~ round(count, digits = -1),
                                .default = round(count, digits = -2))) |> 
  group_by(freq_block) |> summarise(n = n())
```

## Gorilla spreadsheet stimuli

### Original pilot

Create the original spreadsheet for Gorilla.

```{r}
names_combined |> 
  group_by(name) |> 
  summarise(count = n(),
            .groups = "drop") |> 
  filter(count > 3) |> # old spreadsheet
  mutate(freq_block = round(count, digits = -1), # old spreadsheet
         #freq_block = case_when(count <= 100 ~ round(count, digits = -1),
         #                       .default = round(count, digits = -2))
         ) |> 
  select(-count) |> 
  filter(freq_block >= 100) |> # old spreadsheet
  mutate(display = "Rating",
         freq_block = round(freq_block, digits = -2)) |> # added this in, not sure if it does re-generate original though
  select(display, name, freq_block) -> original_gorilla; original_gorilla |> arrange(-freq_block)#Name_Rating_Spreadsheet; Name_Rating_Spreadsheet

# Old spreadsheet, with only 100s and greater, no breakdown below 100, filter(count > 3)
#write_csv(Name_Rating_Spreadsheet, "data/large_files/Name_Rating_Spreadsheet.csv")
```

### Second Gorilla attempt, log ratio based

Attempt a different type of spreadsheet for Gorilla.

```{r}
# combine three types of names to create a subset of names to rate
rbind(
  # these are the most frequent names with HIGH AMAB ratios
  combined.breakdown |> 
    filter(log.ratio>3) |> 
    mutate(freq = log(total_amab)) |> 
    mutate(freq_block = round(freq, digits = 0),
           ppl_per_year = total_amab/years) |> 
    #group_by(freq_block) |> summarise(n = n())
    arrange(ppl_per_year) |> 
    filter(freq > 11) |> 
    mutate(type_rank = rank(-log.ratio, ties.method = "first"),
           type = "amab-biased"),
  # these are the most frequent names with HIGH AFAB ratios
  combined.breakdown |> 
    filter(log.ratio>3) |> 
    mutate(freq = log(total_afab)) |> 
    mutate(freq_block = round(freq, digits = 0),
           ppl_per_year = total_afab/years) |> 
    #group_by(freq_block) |> summarise(n = n())
    arrange(ppl_per_year) |> 
    filter(freq > 10.9) |> # just to get Ashleigh in the list, if I'm honest...
    mutate(type_rank = rank(-log.ratio, ties.method = "first"),
           type = "afab-biased")
) |> 
rbind(
  # these are the most frequent names with HIGHLY BALANCED ratios
  combined.breakdown |> 
    filter(log.ratio<=3) |> 
    mutate(freq = log(total_people)) |> 
    mutate(freq_block = round(freq, digits = 0),
           ppl_per_year = total_people/years) |> 
    #group_by(freq_block) |> summarise(n = n())
    arrange(ppl_per_year) |> 
    filter(freq > 9) |> 
    mutate(type_rank = rank(log.ratio, ties.method = "first"),
           type = "equi-biased")
) -> gorilla_subset; gorilla_subset
```

`r length(gorilla_subset$type)` names. There are:

- `r length(gorilla_subset$type[gorilla_subset$type == "amab-biased"])` highly frequent AMAB-biased names (minimum AMAB people 'per year' attested = `r min(gorilla_subset$ppl_per_year[gorilla_subset$type == "amab-biased"])`)
- `r length(gorilla_subset$type[gorilla_subset$type == "afab-biased"])` highly frequent AFAB-biased names (minimum AFAB people 'per year' attested = `r min(gorilla_subset$ppl_per_year[gorilla_subset$type == "afab-biased"])`)
- `r length(gorilla_subset$type[gorilla_subset$type == "equi-biased"])` highly frequent equi-biased names (minimum total people 'per year' attested = `r min(gorilla_subset$ppl_per_year[gorilla_subset$type == "equi-biased"])`)

```{r}
gorilla_subset |>
  mutate(display = "Rating",
         freq_block = case_when(type_rank <= 10 ~ 0,
                                type_rank <= 30 & type_rank > 10 ~ 1,
                                type_rank <= 90 & type_rank > 30 ~ 2,
                                type_rank <= 170 & type_rank > 90 ~ 3,
                                type_rank <= 300 & type_rank > 170 ~ 4,
                                .default = 5
                                )) |> 
  #group_by(freq_block) |> 
  #summarise(n = n())
  select(display, name, freq_block,type) -> Name_Rating_Spreadsheet; Name_Rating_Spreadsheet

# New spreadsheet with amab/afab-biased and equi-biased names
#write_csv(Name_Rating_Spreadsheet, "data/large_files/Name_Rating_Spreadsheet_3Types.csv")  
```

```{r}
Name_Rating_Spreadsheet |> filter(name == "Andrea")
```


### Visualization of population data for these names

```{r}
gorilla_subset |> 
  ggplot(aes(x = total_afab, 
             y = total_amab)) + 
  theme_bw() +
  geom_point(aes(size = total_people,
                 color = type),
             alpha = .5) +
  ggrepel::geom_text_repel(aes(label = name),
                           max.overlaps = 10, size = 2) +
  scale_y_log10(limits = c(1,10000000)) + scale_x_log10(limits = c(1,10000000)) +
  coord_equal(ratio = 1) +
  NULL
```

```{r}
gorilla_subset |> 
  filter(name %in% original_gorilla$name) |> 
  ggplot(aes(x = log.ratio, y = ppl_per_year, color = type)) +
  theme_bw() +
  geom_point(alpha = .5) +
  ggrepel::geom_text_repel(aes(label = name),
                           max.overlaps = 20, 
                           size = 2) +
  scale_y_log10()
```


## List of names for SEPTA Name Norming experiment

The SEPTA Name Norming experiment used only the USA data, but this code generates the list for all regions, for an expanded and more detailed list.

**Primary question**: Of the names that are assigned to *both* AMAB and AFAB babies, which ones occur at very close to 1:1 ratios?

The main considerations here are finding names that are consistently assigned in a balanced way, over the years, but not over-privileging names that have been attested for many more years or in particular regions, as different regions report over different timeframes. Furthermore, some names have rapidly shifted "gender valence", so there are many possible ways to assign rankings. The logic of this method is described within the code annotations.

```{r namenorming_logratio}
names_combined |> 
    # Include this line to recreate the Name Norming stimuli from this database
  # filter(region == "USA") |> 
    # Put attestations of AMAB and AFAB babies in adjacent columns to calculate ratios, etc
  pivot_wider(names_from = "asab", 
              values_from = c(number,proportion,rank),
                # Unattested cells are given the value 0, since there are no babies with that name in that year.
              values_fill = 0) |> 
    # Since dividing by 0 produces an infinite number, only finite ratios are calculated. 
    # All infinite values are given the value 0, which is equivalent for later calculations
  mutate(ratio_numrFM = case_when(number_M != 0 ~ number_F/number_M,
                                  .default = 0),
           # Calculate the absolute value of the log ratio as a measure of 'balancedness'
         log_ratio_numrFM = log(ratio_numrFM) |> abs()) |> 
    # For all infinite log ratios (when the ratio was assigned a value of 0), remove value (assign NA)
  mutate_if(is.numeric, list(~na_if(., Inf))) |> 
    # Remove NAs and placeholder baby names
  filter(!is.na(log_ratio_numrFM),
         !name %in% c("Baby","Infant","Notnamed","Unknown","Unkown","Unnamed")) |> 
  group_by(name) |> 
    # calculations for ranking appropriateness of each name
  summarise(  # how many babies are recorded as being given each name overall
            total_F = sum(number_F, na.rm = TRUE),
            total_M = sum(number_M, na.rm = TRUE),
              # how many years in each region recorded this name?
            entries = n(),
              # how many regions is the name attested in
            regions = n_distinct(region),
              # how many babies are given this name per year per region?
            mean_F = mean(number_F, na.rm = TRUE)/n_distinct(region),
            mean_M = mean(number_M, na.rm = TRUE)/n_distinct(region),
              # Do not calculate the mean log ratio this way, but I don't know why yet
            ##mean.logratio2 = mean(abs(log(mean_F/mean_M)), na.rm = TRUE),
              # Take the mean of the absolute log ratio values for each name
            mean.logratio = mean(log_ratio_numrFM, na.rm = TRUE),
              # Medians, less affected by outliers
            median.logratio = median(log_ratio_numrFM, na.rm = TRUE),
              # Standard deviation to measure the variance, which will be greater for names that changed valence than those with more static balancedness
            sd.logratio = sd(log_ratio_numrFM, na.rm = TRUE),
              # Standard error to measure certainty of the mean value
            se.logratio = sd(log_ratio_numrFM, na.rm = TRUE)/sqrt(n()),
              # Maximum log ratio to set a threshold for how large the ratios could be in a given year
            max.logratio = max(log_ratio_numrFM, na.rm = TRUE),
              # Minimum log ratio to prioritize names that had perfectly balanced years
            min.logratio = min(log_ratio_numrFM, na.rm = TRUE),
            .groups = "drop") |> 
  mutate(  # mean number of babies per region per year across ASABs
         mean.asab = (mean_F+mean_M)/2,
           # babies per year per region, redistributed to 
         weighted.frequency = mean.asab*entries*regions) |> 
    # arrange focusing on range of log ratios, for dealing with tie-breaking
  arrange(min.logratio, max.logratio, sd.logratio, -weighted.frequency, -mean.asab, -regions, -entries) |> 
    # ranks based on range of log ratio
  mutate(order_logratio = rank(min.logratio, ties.method = "first")) |> 
    # arrange focusing on average values of log ratio, for dealing with tie-breaking
  arrange(mean.logratio, median.logratio, se.logratio, -weighted.frequency) |> 
    # ranks based on average log ratio values
  mutate(order_mean = rank(mean.logratio, ties.method = "first")) |> 
    # arrange focusing on commonness, for dealing with tie-breaking
  arrange(-weighted.frequency, sd.logratio) |> 
    # rank based on commonness
  mutate(order_common = rank(-weighted.frequency,ties.method = "first"), 
           # add previous three ranks to create new ranking value
         combined_order = order_logratio + order_mean + order_common*3, # 3 seems to work across regions?
           # re-rank based on combined rank for simplicity
         rank_order = rank(combined_order, ties.method = "first")) |> 
    # rearrange based on final ranking, for display purposes
  arrange(rank_order) -> names_balanced; names_balanced
```


# HERE BE DRAGONS

Briefly, here are some tests of the dataset to demonstrate its utility.

## Unisex or gender-balanced names

The names in `unisex_names` are a complete list of names that occur at least once in both AMAB and AFAB entries. This does not account for data entry errors or other noise in the datasets.

```{r unisex_old}
#| eval: false
#| include: false
## create a list of AFAB names
#names_combined |> 
#  filter(#region == "USA" & number > 50 | # I no longer am certain it's useful to get rid of these lower frequency #names
#         #  region != "USA" & number > 0,
#         asab == "F") -> afab_names
#
## create a list of AMAB names
#names_combined |> filter(#region == "USA" & number > 50 |  # I no longer am certain it's useful to get rid of #these lower frequency names
#                         #  region != "USA" & number > 0,
#                         asab == "M") -> amab_names
#
## find intersection of AFAB and AMAB names, regardless of frequency
#intersect(afab_names |> 
#            pull(name), 
#          amab_names |> 
#            pull(name)) -> unisex_names
```

```{r}
#| eval: false
#| include: false
#names_combined |> 
#  pivot_wider(names_from = "asab", 
#              values_from = c(number,proportion,rank),
#              values_fill = 0) |> 
#  mutate(ratio_numrFM = case_when(number_M != 0 ~ number_F/number_M,
#                                  .default = 0),
#         log_ratio_numrFM = log(ratio_numrFM) |> abs(),
#         #ratio_propFM = case_when(proportion_M !=0 ~ proportion_F/proportion_M,
#         #                         .default = 0),
#         #log_ratio_propFM = log(ratio_propFM) |> abs(),
#         #ratio_rankFM = case_when(rank_M != 0 ~ rank_F/rank_M,
#         #                         .default = 0),
#         #log_ratio_rankFM = log(ratio_rankFM) |> abs()
#         ) |> 
#  mutate_if(is.numeric, list(~na_if(., Inf))) |> 
#
#  group_by(name, region) |> 
#  summarise(total_F = sum(number_F),
#            total_M = sum(number_M),
#            entries = n(),
#            mean.logratio = mean(log_ratio_numrFM, na.rm = TRUE),
#            median.logratio = median(log_ratio_numrFM, na.rm = TRUE),
#            sd.logratio = sd(log_ratio_numrFM, na.rm = TRUE),
#            se.logratio = sd(log_ratio_numrFM, na.rm = TRUE)/sqrt(n()),
#            max.ratio = max(log_ratio_numrFM, na.rm = TRUE),
#            min.ratio = min(log_ratio_numrFM, na.rm = TRUE),
#            #max.logratio = case_when(number_F>0 & number_M>0 ~ max(log_ratio_numrFM, na.rm = TRUE),
#            #                         .default = NA),
#            #min.logratio = min(log_ratio_numrFM, na.rm = TRUE),
#            .groups = "drop") -> names_balanced; beepr::beep()
```

From the combined names dataset, I separated and expanded the names to compare the number of attestations of a name across se

```{r}
names_balanced$name[1:100] -> unisex_names
```


Of the `unisex_names`, which ones occur in at least 0.05% of the population? This helps control for wildly different population sizes of each country, but also helps weed out noise from data entry errors. 

However, I believe the large population of the USA and some possible larger-scale data entry errors could be boosting names like "Mary" and "Samantha" into this list. It is worth exploring in the future.

```{r list_top_unisex}
#| eval: false
#| include: false
names_combined |> 
  ## CHECK FOR DUPLICATES BEFORE PIVOTING
  # group_by(name,asab,region,year) |> 
  # summarise(n = n(),
  #           .groups = "drop") |> 
  # filter(n != 1)
  ## COMBINE NAMES IF DATA IS WELL STRUCTURED
  pivot_wider(names_from = "asab", 
              values_from = c(number,proportion,rank)) |> # view() # ,values_fn = list(ppg = length)
  filter(name %in% unisex_names,
         proportion_M > 0.0005,
         proportion_F > 0.0005,
         !is.na(proportion_M),
         !is.na(proportion_F)) |> pull(name) |> unique()
```

what was i doing here? looks like creating datasets to label plots (see sandbox)
```{r}
#names_combined |> 
#  pivot_wider(names_from = "asab", values_from = c(number,proportion,rank)) |>
#  filter(name %in% unisex_names,
#         !is.na(proportion_M),
#         !is.na(proportion_F),
#         number_M >= 3,
#         number_F >= 3,
#         #proportion_M > 0.0001,
#         #proportion_F > 0.0001,
#         #name != "Mary",
#         name != "Baby"
#         ) |> 
#  group_by(name, region) |> 
#  summarise(proportion_M = max(proportion_M),
#            proportion_F = max(proportion_F),
#            .groups = "drop") -> prop.labels

names_combined |> 
  pivot_wider(names_from = "asab", values_from = c(number,proportion,rank)) |>
  filter(name %in% unisex_names,
         !is.na(proportion_M),
         !is.na(proportion_F),
         number_M >= 3,
         number_F >= 3,
         #proportion_M > 0.0001,
         #proportion_F > 0.0001,
         #name != "Mary",
         name != "Baby"
         ) |> 
  group_by(name, region) |> 
  summarise(number_M = max(number_M),
            number_F = max(number_F),
            .groups = "drop") -> num.labels

num.labels |> 
  group_by(name) |> 
  summarise(count = n(),
            .groups = "drop") |> 
  arrange(-count) |> 
  #filter(count >=7) |> 
  pull(name) -> top.names.combined
```

Create a table of international names, but why with `num.labels`? go back to this
```{r}
names_combined |> 
  pivot_wider(names_from = "asab", values_from = c(number,proportion,rank)) |>
  filter(name %in% unisex_names,
         !is.na(proportion_M),
         !is.na(proportion_F),
    # WHAT TO EXCLUDE BASED ON RARITY?
         #number_M >= 3,
         #number_F >= 3,
         #proportion_M > 0.0001,
         #proportion_F > 0.0001,
         #name != "Mary",
         name != "Baby",
         name != "Unnamed") |> 
  group_by(name, region) |> 
  summarise(number_M = max(number_M),
            number_F = max(number_F),
            .groups = "keep") |> 
  ungroup(region) |> 
  mutate(count = n()) |> 
  filter(abs(number_M/number_F) >= 0.1,
         abs(number_F/number_M) >= 0.1,
         number_M > 3,
         number_F > 3)|> 
  summarise(count = n(), 
            countries = paste(region, collapse = "; "),
            .groups = "drop") |> 
  arrange(count)  |> 
  ungroup() -> top.names.summary
  
names.table <- list()

for (i in 1:max(top.names.summary$count)) {
  max_length <- top.names.summary |> group_by(count) |> summarise(n = n()) |> pull(n) |> max()
  name_vector <- rep(NA, times = max_length)
  num_of_names <- top.names.summary |> group_by(count) |> summarise(n = n()) |> filter(count==i) |> pull(n)
  for (j in 1:num_of_names) {
    name_vector[j] <- top.names.summary |> filter(count == i) |> pull(name) |> nth(j)
  }
  names.table[[i]] <- name_vector
  rm(name_vector, num_of_names,max_length)
}

names.table %>% map_dfr(~ .x %>% as_tibble(), .id = "count") |> 
  pivot_wider(names_from = count, values_from = value, values_fn = list) |> 
  unnest(cols = everything()) -> international_unisex_names

international_unisex_names |> 
  select(-c("1","2","3")) |> 
  filter(!is.na(`4`)) |> 
  flextable()
```

```{r, fig.height=8, fig.width=18, warning=FALSE}
names_combined |> 
  filter(name %in% c(pull(.data = international_unisex_names, var = `7`),
                     pull(.data = international_unisex_names, var = `8`))) |> 
  pivot_wider(names_from = "asab", values_from = c(number,proportion,rank)) |> 
  ggplot(aes(x = proportion_M, 
             y = proportion_F,
             color = region,
             label = region)) +
  geom_abline(slope = 1, intercept = 0) +
  geom_path(aes(group = region)) +
  ggrepel::geom_text_repel(aes(label = year), 
                           size = 2, 
                           color = "black", 
                           alpha = .5,max.overlaps = 20,) +
  xlab("proportion of the AMAB population registered with this name in a given year") +
  ylab("proportion of the AFAB population registered with this name in a given year") +
  scale_x_log10(labels = scales::percent_format()) +
  scale_y_log10(labels = scales::percent_format()) +
  #scale_color_manual(values = c("red","orange","gold","green3","cyan2","blue","blueviolet","violet")) +
  scale_color_viridis_d(option = "turbo") +
  facet_wrap(~name, scales = "free", ncol = 5) +
  NULL
```


```{r, fig.height=8, fig.width=18, warning=FALSE}
names_combined |> 
  filter(name %in% c(pull(.data = international_unisex_names, var = `7`),
                     pull(.data = international_unisex_names, var = `8`))) |> 
  pivot_wider(names_from = "asab", values_from = c(number,proportion,rank)) |> 
  ggplot(aes(x = number_M, 
             y = number_F,
             color = region,
             label = region)) +
  geom_abline(slope = 1, intercept = 0) +
  geom_path(aes(group = region)) +
  ggrepel::geom_text_repel(aes(label = year), 
                           size = 2, 
                           color = "black", 
                           alpha = .5,max.overlaps = 20,) +
  xlab("proportion of the AMAB population registered with this name in a given year") +
  ylab("proportion of the AFAB population registered with this name in a given year") +
  scale_x_log10() +
  scale_y_log10() +
  #scale_color_manual(values = c("red","orange","gold","green3","cyan2","blue","blueviolet","violet")) +
  scale_color_viridis_d(option = "turbo") +
  facet_wrap(~name, ncol = 5) + #, scales = "free"
  NULL
```


```{r, warning=FALSE, message=FALSE, fig.height=16, fig.width=24}
names_combined |> 
  pivot_wider(names_from = "asab", values_from = c(number,proportion,rank)) |>
  filter(name %in% unisex_names,
         !is.na(proportion_M),
         !is.na(proportion_F),
         proportion_M > 0.0005,
         proportion_F > 0.0005,
         name != "Mary") |>
  arrange(region,name,year) |> 
  filter(name %in% top.names.combined) |> 
  group_by(region, name) |> mutate(n = n()) |> ungroup() |> filter(n > 1) |> 
  ggplot(aes(x = proportion_M, 
             y = proportion_F,
             color = region,
             label = region)) +
  geom_abline(slope = 1, intercept = 0) +
  geom_path(aes(group = region)) +
  ggrepel::geom_text_repel(aes(label = year), 
                           size = 2, 
                           color = "black", 
                           alpha = .5,max.overlaps = 20,) +
  facet_wrap(~name, scales = "free") +
  xlab("proportion of the AMAB population registered with this name in a given year") +
  ylab("proportion of the AFAB population registered with this name in a given year") +
  scale_x_continuous(labels = scales::percent_format()) +
  scale_y_continuous(labels = scales::percent_format()) +
  scale_color_manual(values = c("red","orange","gold","green3","cyan2","blue","blueviolet","violet")) +
  NULL
```

